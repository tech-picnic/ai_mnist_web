from flask import Flask
from flask import render_template
from flask import request
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.examples.tutorials.mnist import input_data

app = Flask(__name__ , static_url_path='')

@app.route("/")
def root(name=None):
    return render_template('predict.html', name=name)


@app.route("/predict", methods=['POST', 'GET'])
def predict():

    canvas = request.form['images']
    print( canvas)

    # 이미 그래프가 있을 경우 중복이 될 수 있기 때문에, 기존 그래프를 모두 리셋한다.
    tf.reset_default_graph()

    num_filters1 = 32

    x = tf.placeholder(tf.float32, [None, 784])
    x_image = tf.reshape(x, [-1, 28, 28, 1])

    #  layer 1
    W_conv1 = tf.Variable(tf.truncated_normal([5, 5, 1, num_filters1],
                                              stddev=0.1))
    h_conv1 = tf.nn.conv2d(x_image, W_conv1,
                           strides=[1, 1, 1, 1], padding='SAME')

    b_conv1 = tf.Variable(tf.constant(0.1, shape=[num_filters1]))
    h_conv1_cutoff = tf.nn.relu(h_conv1 + b_conv1)

    h_pool1 = tf.nn.max_pool(h_conv1_cutoff, ksize=[1, 2, 2, 1],
                             strides=[1, 2, 2, 1], padding='SAME')

    num_filters2 = 64

    # layer 2
    W_conv2 = tf.Variable(
        tf.truncated_normal([5, 5, num_filters1, num_filters2],
                            stddev=0.1))
    h_conv2 = tf.nn.conv2d(h_pool1, W_conv2,
                           strides=[1, 1, 1, 1], padding='SAME')

    b_conv2 = tf.Variable(tf.constant(0.1, shape=[num_filters2]))
    h_conv2_cutoff = tf.nn.relu(h_conv2 + b_conv2)

    h_pool2 = tf.nn.max_pool(h_conv2_cutoff, ksize=[1, 2, 2, 1],
                             strides=[1, 2, 2, 1], padding='SAME')

    # fully connected layer
    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * num_filters2])

    num_units1 = 7 * 7 * num_filters2
    num_units2 = 1024

    w2 = tf.Variable(tf.truncated_normal([num_units1, num_units2]))
    b2 = tf.Variable(tf.constant(0.1, shape=[num_units2]))
    hidden2 = tf.nn.relu(tf.matmul(h_pool2_flat, w2) + b2)

    keep_prob = tf.placeholder(tf.float32)
    hidden2_drop = tf.nn.dropout(hidden2, keep_prob)

    w0 = tf.Variable(tf.zeros([num_units2, 10]))
    b0 = tf.Variable(tf.zeros([10]))
    k = tf.matmul(hidden2_drop, w0) + b0
    p = tf.nn.softmax(k)

    # prepare session
    sess = tf.InteractiveSession()
    sess.run(tf.global_variables_initializer())
    saver = tf.train.Saver()
    saver.restore(sess, '/tmp/cnn_session')

    print('reload has been done')
    #fcanvas = [float(z) for z in canvas.split(",")]

    lcanvas = canvas.split()
    lcanvas = [float(v) for v in lcanvas]

    #fcanvas = [float(list_item) for list_item in lcanvas]
    #fcanvas = []

    #for i in range(len(lcanvas)-1):
    #   fcanvas[i] = float(lcanvas[i])

    print(lcanvas)

    p_val = sess.run(p, feed_dict={x: [lcanvas], keep_prob: 1.0})
    print("p_val:"%p_val)

    fig = plt.figure(figsize=(4, 2))
    pred = p_val[0]
    subplot = fig.add_subplot(1, 1, 1)
    subplot.set_xticks(range(10))
    subplot.set_xlim(-0.5, 9.5)
    subplot.set_ylim(0, 1)
    subplot.bar(range(10), pred, align='center')
    plt.show()
    print( canvas)

    return render_template('predict.html', result=p_val)


if __name__ == "__main__":
    app.run()